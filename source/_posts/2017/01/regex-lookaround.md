---
title: 正则表达式 — 环视
date: 2017-01-19
tags:
- PHP
categories:
- 语言
- PHP
---

[环视](https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F) 是正则中的一个难点，但是在实际应用中使用起来却很方便。**环视** 不匹配文本中的任何字符，只匹配文本中的 **[特定位置](#)** 。环视类似于定位符`^`、`$`、`\b`，不会占用字符。<!--more-->

环视分为 **顺序环视** 和 **逆序环视** 两种。

# 顺序环视

```Bash
   类型	          正则表达式	                   匹配成功的条件
肯定顺序环视	   (?=exp)	                子表达式能够匹配 右侧 文本
否定顺序环视	   (?!exp)	                子表达式不能匹配 右侧 文本
```

顺序环视会检查子表达式`exp` 能否匹配成功，且 **只寻找子表达式匹配成功时 [左侧](#) 位置**，即子表达式能够匹配右侧文本。

**小试牛刀**

下面需要将每个操作系统用`,`分隔，正则表达式为`(?=Win)`，实现代码如下：

```PHP
$need = 'CentOS7Win7Win10';
$need = preg_replace('/(?=Win)/', ',', $need);
echo $need, PHP_EOL;
```

替换后的文本字符串为：

```PHP
CentOS7,Win7,Win10
```

# 逆序环视

```PHP
   类型	          正则表达式	                  匹配成功的条件
肯定逆序环视	  (?<=exp)	             子表达式能够匹配 左侧 文本
否定逆序环视	  (?<!exp)	             子表达式不能匹配 左侧 文本
```

逆序环视同样会检查子表达式`exp` 能否匹配成功，且** 只寻找子表达式匹配成功时 [右侧](#) 位置**，即子表达式能够匹配左侧文本。

**小试牛刀**

这里继续将上例中的系统名和版本之间用`-`分隔，正则表达式为`(?<=(CentOS|Win))`，代码如下：

```PHP
$need = preg_replace('/(?<=CentOS|Win)/', '-', $need);
echo $need, PHP_EOL;
```

输出为：

```PHP
CentOS-7,Win-7,Win-10
```

# 经典例子

**需求**：银行为了方便用户查阅存款金额，需要将存款金额整数部分从右往左每隔**3**位数字用 `,` 分隔。即`12345`需要显示为`12,345`。

实现需求前，分析要实现的正则表达式的功能为：

>1. `,`左侧一定要有数字；  
>2. 从右往左每**3**位数字需要插入`,`字符；

先写出能从右往左匹配每**3**位数字的 **左侧** 位置的正则表达式，可知是 **顺序环视** 正则：

```PHP
(?=(\d{3})+$)
```

该正则表达式在存款位数为3的整数倍时，也会在首位数字前添加`,`字符，所以需要限定为数字的 **右侧** 位置才添加`,`字符，使用 **逆序环视** 正则为：

```PHP
(?<=\d)
```

故，总的正则表达式为：

```PHP
(?<=\d)(?=(\d{3})+$)
或
(?=(\d{3})+$)(?<=\d)
```

最后，实现 **代码** 为：

```PHP
$need = '123456';
$need = preg_replace('/(?<=\d)(?=(\d{3})+$)/', ',', $need);
echo $need, PHP_EOL;
```

运行结果：

```PHP
123,456
```






